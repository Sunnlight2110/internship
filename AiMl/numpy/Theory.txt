Random numbers
    Generated by numpy.random module, which provides various functions.
        rand:
            Generates array by specified shape, filled with random values between 0 and 1
                i.g. np.random.rand(3,2) (shape is 3 and 2)
        
        randint:
            Returns random integer from discrete uniform distribution.
            It generates single integer or an array of integers based on the size parameter.
                i.g. np.random.randint(10, size = 5) (Generates 1D array of 5 integers between 0 and 10)
            syntex
                (start,end,size)
        
        Random:
            It is similer to rand, but generator created with np.random.default_rng()
                i.g. np.random.random(2,2)

Random data distribution:
    Can be generated using numpy.random module
        Choice:
            Generates sample from given arrays
                i.g. np.random.choice([1,2,3,4,5,6,7,8,9,0],size = 5)  Generates 1D array of 5 size with random numbers from 0 to 1
        
        Random:
            random(): Returns random floats in the half-open interval.
                i.g. X = np.random.default_rng()

                    Integer:
                        returns random floats in half open intervals
                            i.g. X.integers(low, high, size)

                    Normal:
                        Draws random samples from normal(Gaussian) distribution
                        (bell curve. It’s used to describe things that naturally cluster around an average)
                            i.g. rng.normal(loc=0, scale=1, size=(100))

                    beta:
                        Draws samples from a Beta distribution
                        (Used when your data is between 0 and 1)
                            i.g. X.beta(a=2, b=3, size=(100))

                    Binomial:
                        Draws samples from a Binomial distribution
                        This is for yes/no or success/failure situations,
                            i.g. X.binomial(n=10, p=0.5, size=(100))

Normal distribution(Gaussian distribution):
    Fits probability distribution of many events
    Use case: The bell curve — when most of the data is clustered around a mean, with fewer extreme values.
    Example: Height and weight distributions of a population, test scores in exams, and measurement errors in scientific experiments. It's the go-to distribution for modeling natural phenomena.

    Function: np.random.normal()
        Has 3 parameters
            loc: Mean
            scale: standared division(how far graph distribution should be)
            size = shape of array

            i.g. random.normal(loc = 1, scale = 2, size = (2,3))
                (in array, base will be 1 but values may standared division is 2, meaning value will spread out within range)

Binomial distribution
    discrete distribution, discribes outcome of binary scenarios
    Use case: When there are two possible outcomes (like success/failure) in a fixed number of trials.
    Example: Coin tosses (heads or tails), defective items in a factory (pass/fail), or determining the number of successful students out of a class.

    Function: np.random.binomial()
        has 3 parameters
            n = number of trails
            p = probability of occurence of each trails
            size = shape of array

            i.g. np.random.binomial(n=10,p=0.5,size=(100))
                (it means there will be 100 experiments, in each experiments 10 trails will be conducted, in each trial being success has probability of 'p')

poisson distribution
    Discrete distributed
    Estimates how many time an event can happen in specified time
    Use case: Used for modeling the count of events that happen rarely over a fixed interval of time or space.
    Example: Number of phone calls received at a call center in an hour, number of accidents at a traffic intersection in a day, or number of decay events in a radioactive substance.
    
    Function: random.poisson()
        2 parameters
            lam: rate or known numbers of occurence
            size = shape of array

            i.g. random.poisson(lam=2, size=10)
                (Each number in array represents how many events occur in a fixed interval, where the average number of events (λ) is 2)

Uniform distribution:
    Used to describe probability where every event has equal chance of occurring
    Use case: When you need equal probability for all outcomes.
    Example: Random sampling of points on a line or for shuffling items, such as randomly picking a card from a deck. Also used in simulations like generating random numbers for a Monte Carlo simulation.

        Function:
            has 3 parameters
                low: lower bound
                high: higher bound
                size

                i.g. np.random.uniform(0, 10, size=5)
                    (Every numbers between 0 to 10, has equal chance of getting picked)

Logistic distribution:
    Used in ML in logistic regression, neural network etc.
    Use case: Similar to the normal distribution but with heavier tails (more extreme values).
    Example: Logistic regression models (used in machine learning), growth models in biology or economics, or modeling of returns in finance.
    
    Function:
        3 parameters
            loc: Mean
            scale: standared division(how far graph distribution should be)
            size = shape of array

            i.g.  random.logistic(loc=1, scale=2, size=(2, 3))
                (The random numbers are distributed around the mean of 1, but they are spread out due to the scale of 2.)
                
Multi-nomial distribution
    generalized version of bionomial
    Use case: Generalization of the binomial distribution, used when there are more than two possible outcomes.
    Example: Rolling a dice (each face of the dice has a probability), classifying items into multiple categories (e.g., survey responses with multiple choices), or modeling election outcomes with multiple candidates.
    
    Function:
        has 3 parameters
            n - number of possible outcomes
            pvals - list of probabilties of outcomes 
            size - The shape of the returned array.

            i.g. random.multinomial(n=6, pvals=[1/6, 1/6, 1/6, 1/6, 1/6, 1/6], size = (2,3))
            (It generates 2x3 array where each element represents the outcome of an experiment (like rolling a die 6 times).
                The output shows how many times each face of the die (or each outcome) appeared in each of the 2 experiments, each having 6 trials with an equal probability of each outcome.
                Rows = Experiments, columns = outputs
                )

Exponential distribution:
    used for discribeing time till next event:
    
    Function:
        2 parameters
        scale -  exponential distribution(Determines spread out of values).
        size - The shape of the returned array.
        
        i.g. random.exponential(scale=2, size=(2, 3))
            (The exponential distribution is used to model the time between events in a Poisson process (events occurring independently at a constant average rate))

Chi square distribution:
    used as a basis to verify the hypothesis.
    way to measure how "spread out" or "different" those things are, based on randomness.
    Use case: Used in statistical inference tests, like testing goodness of fit or for variances.
    Example: Hypothesis testing in statistics (e.g., chi-squared test for independence or goodness-of-fit), analysis of variance (ANOVA), and evaluating model fit in regression.

    Function: r
        df - (degree of freedom)(number that tells you how many random things you're looking at. )
        size - The shape of the returned array.

        i.g. random.chisquare(df=2, size=(2, 3))
        (The Chi-Square distribution with df=2 will have values that are most likely near 0, and it decays quickly as the values get larger.)

Rayleigh distribution
    Used in signal processing
    Use case: When modeling magnitude of a vector that has two independent components.
    Example: Noise level in signal processing, wind speeds, or random direction movements of particles in physics.

    Function:
        2 parameter
        scale - (standard deviation) 
        size - The shape of the returned array.

        i.g. random.rayleigh(scale=2, size=(2, 3))
        (The Rayleigh distribution generates random values that are most likely to be near 0, and as the values increase, the probability decreases.)

Pareto distribution:
    A distribution following Pareto's law i.e. 80-20 distribution(20% factors cause 80% outcome)
    Use case: Used for modeling power-law distributions, where a small number of items hold most of the "weight" or value.
    Example: Wealth distribution (a few people have most of the money), city populations (a few cities are much larger than the rest), or internet traffic (a few websites get most of the visitors).

    Function:
        a = shape parameter
        size = the shape of returned array

        i.g. random.pareto(a=2, size=(2, 3))
        (it means the distribution will be steeper (fewer large numbers). As a increases, the distribution becomes "sharper," meaning larger values are less likely to occur.)

Zipf distribution:
    used to sample data based on zipf's law.
    Zipf's Law: In a collection, the nth common term is 1/n times of the most common term.
        E.g. the 5th most common word in English occurs nearly 1/5 times as often as the most common word.
    Use case: Used for modeling ranked distributions, where the frequency of items follows a power law.
    Example: Word frequencies in large texts (like "the" being used way more than "xylophone"), traffic to websites, or product sales (few products are bought far more than others)
    
    Function:
        a - distribution parameter.(larger the a, more equal distribution becomes)
        size - The shape of the returned array.

        i.g. random.zipf(a=2, size=(2, 3))
            (The Zipf distribution models situations where a few things are very common (like the most frequent words in a language) and many things are very rare.)

Uniform: Random sampling (card drawing, simulations).
Normal: Heights, test scores, natural data.
Binomial: Coin tosses, yes/no trials.
Poisson: Rare events over time (phone calls, accidents).
Rayleigh: Magnitudes of vectors, wind speeds, noise levels.
Pareto: Power-law distributions (wealth, internet traffic).
Zipf: Frequency of words, product sales.
Chi-Square: Hypothesis testing, model fit evaluation.
Exponential: Time between events, waiting times.
Logistic: Logistic regression, growth models.
Multinomial: Dice rolls, survey responses.



